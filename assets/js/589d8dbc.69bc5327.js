"use strict";(self.webpackChunktouchlab=self.webpackChunktouchlab||[]).push([[484],{3905:(e,t,n)=>{n.d(t,{Zo:()=>g,kt:()=>d});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},g=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,g=l(e,["components","mdxType","originalType","parentName"]),p=c(n),d=o,m=p["".concat(s,".").concat(d)]||p[d]||u[d]||r;return n?a.createElement(m,i(i({ref:t},g),{},{components:n})):a.createElement(m,i({ref:t},g))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},7319:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var a=n(7462),o=(n(7294),n(3905));const r={},i="Performance",l={unversionedId:"PERFORMANCE",id:"PERFORMANCE",title:"Performance",description:"While performance of logging is not generally a major concern, logging should endeavor to impact performance as little",source:"@site/docs/PERFORMANCE.md",sourceDirName:".",slug:"/PERFORMANCE",permalink:"/docs/PERFORMANCE",draft:!1,editUrl:"https://github.com/touchlab/Kermit/tree/main/website/docs/PERFORMANCE.md",tags:[],version:"current",lastUpdatedBy:"Kevin Galligan",lastUpdatedAt:1676857768,formattedLastUpdatedAt:"Feb 20, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"NON_KOTLIN",permalink:"/docs/NON_KOTLIN"}},s={},c=[{value:"Mutable Configuration",id:"mutable-configuration",level:2},{value:"Logging Calls",id:"logging-calls",level:2},{value:"Log Call Stripping (AKA Chisel)",id:"log-call-stripping-aka-chisel",level:2}],g={toc:c};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},g,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"performance"},"Performance"),(0,o.kt)("p",null,"While performance of logging is not generally a major concern, logging should endeavor to impact performance as little\nas possible. Also, while most projects probably need not be concerned with logging performance, other projects may\nbe very concerned with runtime performance, and all production large-scale apps might be better off disabling logging\nbelow a certain level. Runtime performance impact has been a concern of Kermit design since the beginning and continues\nto drive various parts of the design and architecture."),(0,o.kt)("p",null,"TL;DR you probably don't need to worry about this much, but you can tweak a few things in Kermit to maximize performance\nif desired."),(0,o.kt)("h2",{id:"mutable-configuration"},"Mutable Configuration"),(0,o.kt)("p",null,"Kermit originally had two design features that turned off potential users. No mutable config, and no global logger.\nMutable config meant being able to change your log writers and severity levels at runtime, after being initially set. Global\nlogging is a simple concept. You needed to creat your own instance of a ",(0,o.kt)("inlineCode",{parentName:"p"},"Logger")," and pass it around, vs just being\nable to do something like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'Logger.i { "Hello" }\n')),(0,o.kt)("p",null,"They're actually related issues. To support global logging, you'd need to be able to set logging config after the global\ninstance was initialized. That implies mutable config."),(0,o.kt)("p",null,"What's wrong with mutable config? Well, mutable config requires thread-sharable state. On the JVM that implies at least\nvolatile. On Kotlin/Native, that means AtomicReference values (the new memory model may change things a bit, but we don't\nknow yet). Effectively that means each time you call a log method, you need to access atomic state. On the JVM this is\narguably not much of an issue, but on native, accessing state back by atomics was determined to be a bit excessive.\nBecause our primary use case was logging in production apps, creating a logging and passing it around with DI made\nglobal logging and mutable config unnecessary."),(0,o.kt)("p",null,"The lack of mutable config and global logging avoided the volatile/atomic situation altogether, and that was how the earlier\nversion of Kermit worked. You can still use Kermit in that way (and for native mobile apps, I would recommend that you do).\nHowever, we've added global logging and mutable state by popular demand. Performance won't be an issue for the vast majority\nof uses, but be aware that you can change how you configure logging to optimize performance if desired."),(0,o.kt)("h2",{id:"logging-calls"},"Logging Calls"),(0,o.kt)("p",null,"The logging calls take lambda args that return strings. The goal is to avoid evaluating those lambdas if you're not actually\nlogging the string. We've added \"regular\" calls that take a string directly if that's preferred. That means instead of this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'Logger.i { "Hello" }\n')),(0,o.kt)("p",null,"You can do this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'Logger.i("Hello")\n')),(0,o.kt)("p",null,"The lambda log calls are inline, and if your minimum severity is configured such that Kermit should skip that call, it will\ndo so without any deeper function calls. Just a check to minimum severity. In summary that means performance should be\nabout as good as we can make it in normal situations."),(0,o.kt)("h2",{id:"log-call-stripping-aka-chisel"},"Log Call Stripping (AKA Chisel)"),(0,o.kt)("p",null,"If you plan to disable logging in release builds, rather that doing so by config, you can run a compiler plugin to simply\nstrip logging calls entirely. This will avoid the checking logic, as well as (slightly) reduce binary output size."))}u.isMDXComponent=!0}}]);